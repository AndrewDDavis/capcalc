#!/usr/bin/env python
#
#   Copyright 2016 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
#       $Author: frederic $
#       $Date: 2016/06/14 12:04:50 $
#       $Id: histnifti,v 1.8 2016/06/14 12:04:50 frederic Exp $
#
from __future__ import print_function
import sys
import getopt
import string
import rapidtide.tide_funcs as tide
from sklearn.cluster import KMeans, MiniBatchKMeans

from numpy import r_, zeros, ones, shape, where, sort
from pylab import *

def usage():
    print('usage: extracttcs fmrifile templatefile outputfile [--stdnorm] [--pctnorm] [--ppnorm] [--varnorm] [--nonorm]')
    print('')
    print('required arguments:')
    print('    inputfile        - the name of the file with the kmeans cluster centers')
    print('    templatefile     - the name of the template region file')
    print('    outputfile       - the name of the output text file')
    print('')
    print('optional arguments:')
    print('    --nonorm         - don\'t normalize timecourses')
    print('    --pctnorm        - scale each timecourse to it\'s percentage of the mean (default)')
    print('    --varnorm        - scale each timecourse to have a variance of 1.0')
    print('    --stdnorm        - scale each timecourse to have a standard deviation of 1.0')
    print('    --ppnorm         - scale each timecourse to have a peak to peak range of 1.0')
    print('')
    return()


# get the command line parameters
if len(sys.argv) < 4:
    usage()
    exit()

# handle required args first
inputfilename = sys.argv[1]
templatefile = sys.argv[2]
outputfile = sys.argv[3]

normmethod = 'pctnorm'

# now scan for optional arguments
try:
    opts, args = getopt.getopt(sys.argv[3:], "h", ["nonorm", "pctnorm", "varnorm", "stdnorm", "ppnorm", "help"])
except getopt.GetoptError as err:
    # print help information and exit:
    print(str(err))  # will print something like "option -x not recognized"
    usage()
    sys.exit(2)

for o, a in opts:
    if o == "--nonorm":
        normmethod = 'none'
        print('will not normalize timecourses')
    elif o == "--pctnorm":
        normmethod = 'pctnorm'
        print('will normalize timecourses to percentage of mean')
    elif o == "--stdnorm":
        normmethod = 'stdnorm'
        print('will normalize timecourses to standard deviation of 1.0')
    elif o == "--varnorm":
        normmethod = 'varnorm'
        print('will normalize timecourses to variance of 1.0')
    elif o == "--ppnorm":
        normmethod = 'ppnorm'
        print('will normalize timecourses to p-p deviation of 1.0')
    elif o == "-h" or o == '--help':
        usage()
        exit()
    else:
        assert False, "unhandled option"

print('loading data')
input_img, input_data, input_hdr, thedims, thesizes = tide.readfromnifti(inputfilename)
template_img, template_data, template_hdr, templatedims, templatsizes = tide.readfromnifti(templatefile)
    
if not tide.checkspacematch(thedims, templatedims):
    print('template file dimensions and input fmri file do not match')
    sys.exit()

xsize = thedims[1]
ysize = thedims[2]
numslices = thedims[3]
numtimepoints = thedims[4]
numvoxels = int(xsize) * int(ysize) * int(numslices)
templatevoxels = reshape(template_data, (numvoxels)).astype(int)
inputvoxels = reshape(input_data, (numvoxels, numtimepoints))
numregions = max(templatevoxels)
timecourses = zeros((numregions, numtimepoints), dtype='float')

for theregion in range(1, numregions + 1):
    meantimecourse = mean(inputvoxels[where(templatevoxels == theregion), :])
    if normmethod == 'nonorm':
        timecourses[theregion, :] = meantimecourse - mean(meantimecourse)
    elif normmethod == 'pctnorm':
        timecourses[theregion, :] = tide.pcnormalize(meantimecourse)
    elif normmethod == 'varnorm':
        timecourses[theregion, :] = tide.varnormalize(meantimecourse)
    elif normmethod == 'stdnorm':
        timecourses[theregion, :] = tide.stdnormalize(meantimecourse)
    elif normmethod == 'ppnorm':
        timecourses[theregion, :] = tide.ppnormalize(meantimecourse)
    else:
        print('illegal normalization method')
        usage()
        sys.exit()
    
tide.writenpvecs(timecourses, outputfile)
